####################
一致性
####################



一致性
==========================


考虑

* Liveness

或说可终止性，非失败进程在有限的时间内能做出决定

* Consensus safety

所有的进程必须夺最终的决定达成一致

* legal

算法做出的决定值必须在其他进程(客户端)的期望值范围之内，要么 yes 或 no， 不能给出不确定的回答

以数据为中心的一致性模型
-------------------------

1） 严格一致性 Strong Consistency

强一致性，可线性化，是要求最高的一致性模型

2） 顺序一致性  Sequential Consistency

可序列化，放弃全局时钟，改为分布式逻辑时钟

3） 因果一致性  Causal Consistency

* 本地顺序：本进程中，事件执行的顺序即为本地因果顺序
* 异地顺序：如果读操作返回的是写操作的值，那么该写操作 在顺序上一定在读操作之前
* 闭包传递：与时钟向量里面定义的一样，如果  a -> b 且 b -> c，那么肯定也有 a -> c

对于具有潜在因果关系的写操作，所有进程看到的执行顺序应相同
没有因果关系的并发写操作在不同主机上被看到的顺序可以不相同。

例如微博和朋友圈的评论

4）可序列化一致性  Serialiizable Consistency

操作的历史等同于某种单一原子顺序发生的历史，但对于调用和完成时间则没有说明
它允许对操作进行任意排序，只要顺序看起来是原子的即可，




以用户为中心的一致性模型
-------------------------

最终一致性 Eventual Consistency

如果更新的时间间隔比较长，那么所有的副本最终能达到一致性


一致性协议
========================

1) 让服务器集群作为一个整体对外服务
2）即使一小部分服务器发生了故障，也能对外服务

生产环境的相关要求

* 安全性： 在非拜占庭错误模型的条件下，永远不会返回一个错误的结果

即要处理网络延迟，网络分区（通信断开），丢包，冗余和乱序等错误

* 高可用：只要集群中大部分机器能运行，能互相通信且能与客户端通信，那么这个集群就可用

* 不依赖时序: 时钟错误和极端情况下的消息延迟只有在最坏情况下才会引起可用性问题





FLP 不可能性
------------------------

一个RSM(复制状态机模型)系统要容忍 N 个拜占庭错误，至少需要 2N + 1 个复制节点。
如果错误类型范围缩小到进程失败，则至少需要 N+1 个节点才能容错。


.. epigraph::

    FLP Impossibility
    No completely asynchronous consensus protocol can tolerate even a single unannounced process death

    没有一个完备的异步共识协议能搞定即使一个没有公示的进程崩溃


一个正确的一致性算法，能够在异步通信模型下同时保证一致性（C) 和可终止性(A), 这是做不到的

例如：

    甲，乙，丙三个人各自分开进行投票，有个人可能会暂时离开和睡着，一旦丙睡着了，甲投0，乙投1， 这就无法达成共识了


拜占庭将军问题
--------------------------------

拜占庭将军问题由 Leslie Lamport 于1980 在其论文 "Reaching agreement in the presence of faults" 中提出。

我来改写一下， 场景为三四十年代的上海

由于日伪对于我地下情报机关的破坏，我们若干个敌后特工队之间只能采取电报静默，各个特工队只能通过传统的信差传递消息。

在采取重大行动时，需要各个特工队协调一致，由于日伪间谍和内部叛徒的破坏和滲通，并非每个队长和信差都是可依赖的。

这样我们英勇的敌后特工队们怎么能排除间谍和叛徒的影响来达到一致的决议和行动呢？



Paxos 协议
================================

1）类似拜占庭将军这样的分布式一致性问题是否有解
2）如果有解话需要满足什么样的条件
3）基于特定前提条件，提出一种解法


方法如下
------------------

假设有一组这些敌后特工队所提出行动提案，并且能保证所有消息是完整不能被篡改的

1. 只有被提出的提案才能被选定(chosen)

1. 这些所提出的提案中，只能有一个会被选定

3. 一个提案被选定后，队长们可以获得被选定的提案信息

这些队长们可以有三个角色， Proposer, Acceptor, Learner

P1. 一个 Acceptor 必须批准它收到的第一个提案

P2. 如果编号为 M_0, 值为 V0 的提案 [M_0, V_0] 被选定了，那么所有比编号 M_0 更高的，且被选定的提案，其值必须也为 V0


基本流程
------------------

1. Proposer 生成提案

1) Prepare 请求

Proposer 张队长向诸位队长发送提案， 提案编号为 M_n

诸位队长要么接受批准提案，并保证不再批准任何编号小于 M_n 的提案
要么就向 Proposer 反馈已经批准过的提案 M_q, M_q < M_n

2) Accept 请求

如果 Proposer 收到了来自半数以上的 Acceptor 的响应结果，那么它就可以产生编号为 M_n 值为 V_n 的提案，
并再次发送给 Acceptor 集合


2. Acceptor 批准提案

1) 响应 Prepare 请求
没有更大编号的就行

2) 响应 Accept 请求



例如: 闸北区的张队长提议上海的5个交通队周末零点突袭日军的看守所，救出身陷囹圄的情报员

阶段一: Prepare Request

* 交通员将张队长的提案[M_8, V_8] 准备请求(prepare request )发送至半数以上的特工队长手中

* 李队长收到后发现这是最新的准备请求,就把上一次最大的请求号 M_7 反馈给张队长，并承诺不再批准任何编号小于 M_8 的请求

阶段二: Accept Request

* 一旦张队长收到了半数以上的 >=3 的对于 [M_8, V_8] 准备请的响应，他就会发送一个 [M_8, V_8] 的接受请求(Accept Request)

* 李队长，王队长，陈队长都收到了这个 [M_8, V_8] 的 accept request，如果他们还没有对 M_8 以上编号的 Prepare request, 那他们就批准通过这个提案

所以最终提案通过 - "周末零点突袭日军的看守所，救出身陷囹圄的情报员"



Raft
=====================

see `<raft>`_



